# 01. 왜 테스트가 필요한가?

## 1. 학습 목표

- 소프트웨어 테스트가 왜 필수적인지 이해한다
- 수동 테스트와 자동 테스트의 차이를 설명할 수 있다
- 테스트 피라미드의 개념을 이해한다
- 버그가 늦게 발견될수록 비용이 증가하는 원리를 안다
- 예지보전(Predictive Maintenance) 시스템에서 테스트의 중요성을 인식한다

## 2. 동기부여 (예지보전 관점)

### 공장 설비에서 테스트 없는 코드의 위험성

예지보전 시스템은 공장 설비의 온도, 진동, 압력 등의 센서 데이터를 실시간으로 분석하여
설비 고장을 사전에 예측합니다. 만약 이 시스템에 버그가 있다면:

- **온도 변환 함수에 버그**: 섭씨 → 화씨 변환이 잘못되면 과열 경고가 누락될 수 있음
- **평균 온도 계산 오류**: 설비 상태를 잘못 판단하여 불필요한 정지 또는 고장 방치
- **데이터 필터링 버그**: 이상치를 놓쳐서 설비 손상이 발생

실제 사례: 한 제조업체에서 온도 센서 데이터 처리 로직의 단순한 계산 오류로 인해
설비 과열을 감지하지 못했고, 이로 인해 수억 원의 설비 교체 비용이 발생했습니다.

**테스트 코드는 보험과 같습니다.** 작성할 때는 번거롭지만, 문제를 미리 발견해줍니다.

## 3. 핵심 개념 설명

### 3.1 버그의 비용 곡선

버그를 발견하는 시점이 늦어질수록 수정 비용이 기하급수적으로 증가합니다:

| 발견 시점 | 상대적 비용 | 예시 |
|-----------|------------|------|
| 코딩 중 | 1x | IDE에서 즉시 수정 |
| 단위 테스트 | 5x | 테스트 실패로 발견 |
| 통합 테스트 | 15x | 모듈 간 충돌 발견 |
| 시스템 테스트 | 50x | QA 팀이 발견 |
| 운영 중 | 150x+ | 설비 고장으로 발견 |

### 3.2 수동 테스트 vs 자동 테스트

```python
# 수동 테스트: 매번 직접 실행하고 눈으로 확인
# "음... 100도를 넣으면 212가 나와야 하는데... 맞나?"
result = celsius_to_fahrenheit(100)
print(result)  # 212.0 이 나오는지 눈으로 확인

# 자동 테스트: 코드가 자동으로 검증
def test_celsius_to_fahrenheit():
    assert celsius_to_fahrenheit(100) == 212.0  # 자동 검증!
    assert celsius_to_fahrenheit(0) == 32.0
    assert celsius_to_fahrenheit(-40) == -40.0
```

**자동 테스트의 장점:**
- 반복 실행 가능 (하루에 수백 번도 가능)
- 실수 없이 정확하게 검증
- 코드 변경 시 기존 기능 보호 (회귀 테스트)
- 문서화 역할 (코드가 어떻게 동작하는지 보여줌)

### 3.3 테스트 피라미드

```
        /\
       /  \        E2E 테스트 (적음, 느림, 비쌈)
      /    \       - 전체 시스템 테스트
     /------\
    /        \     통합 테스트 (중간)
   /          \    - 모듈 간 연동 테스트
  /------------\
 /              \  단위 테스트 (많음, 빠름, 저렴)
/________________\ - 함수/클래스 단위 테스트
```

이 교육과정에서는 **단위 테스트**부터 시작하여 점차 상위 레벨로 나아갑니다.

### 3.4 리팩토링 안전망

테스트가 있으면 코드를 자신 있게 개선할 수 있습니다:

```python
# 원래 코드 (느린 버전)
def calculate_average_temp(readings):
    total = 0
    for r in readings:
        total += r
    return total / len(readings)

# 리팩토링된 코드 (더 깔끔한 버전)
def calculate_average_temp(readings):
    return sum(readings) / len(readings)

# 테스트가 있으면 리팩토링 후에도 정확성을 즉시 확인 가능!
```

### 3.5 실제 버그 찾기 예제

아래 코드에는 미묘한 버그가 있습니다. 어디에 있는지 찾아보세요:

```python
def celsius_to_fahrenheit(celsius):
    """섭씨를 화씨로 변환한다."""
    return celsius * 9/5 + 32

def is_overheating(temp_celsius, threshold=80.0):
    """설비 과열 여부를 판단한다."""
    return temp_celsius > threshold  # >= 가 아닌 > 사용 - 경계값 문제!

def calculate_average_temp(readings):
    """센서 읽기 값들의 평균 온도를 계산한다."""
    if not readings:
        return 0  # 빈 리스트일 때 0을 반환 - 이게 맞을까?
    return sum(readings) / len(readings)
```

이러한 미묘한 버그들은 테스트 없이는 발견하기 매우 어렵습니다.

## 4. 실습 가이드

### 실습 1: 버그가 있는 코드 테스트하기

1. `src_temperature.py`를 열어 코드를 살펴보세요
2. `test_temperature.py`를 실행하여 어떤 테스트가 실패하는지 확인하세요:
   ```bash
   pytest test_temperature.py -v
   ```
3. `src_temperature_fixed.py`와 비교하여 버그가 무엇이었는지 확인하세요

### 실습 2: 처음 테스트 작성해보기

1. `exercises/exercise_01.py`를 열어보세요
2. TODO 주석을 따라 테스트를 완성하세요
3. 테스트를 실행하세요:
   ```bash
   pytest exercises/exercise_01.py -v
   ```

## 5. 연습 문제

### 연습 1: 센서 데이터 유효성 검사 테스트
`exercises/exercise_01.py`에서 센서 데이터 유효성 검사 함수에 대한 테스트를 작성하세요.

### 연습 2: 버그 찾기
다음 코드에서 버그를 찾고, 이를 잡을 수 있는 테스트 케이스를 생각해보세요:

```python
def max_temperature(readings):
    """읽기 값 중 최대 온도를 반환한다."""
    max_temp = 0  # 버그: 음수 온도가 있으면?
    for r in readings:
        if r > max_temp:
            max_temp = r
    return max_temp
```

### 연습 3: 테스트 케이스 설계
진동 센서의 이상 감지 함수가 있다고 가정합니다. 어떤 테스트 케이스를 작성해야 할지
목록을 만들어보세요. (정상 범위, 경계값, 이상값, 빈 데이터 등)

## 6. 퀴즈

### Q1. 버그 비용
운영 중에 발견된 버그는 개발 중 발견된 버그보다 비용이 얼마나 더 드나요?
- A) 2배
- B) 10배
- C) 50~150배 이상
- D) 비용 차이 없음

**정답: C)** 운영 중 발견된 버그는 설비 정지, 데이터 손실, 안전 사고 등의
추가 비용이 발생하여 50~150배 이상의 비용이 듭니다.

### Q2. 테스트 피라미드
테스트 피라미드에서 가장 많이 작성해야 하는 테스트 유형은?
- A) E2E 테스트
- B) 통합 테스트
- C) 단위 테스트
- D) 수동 테스트

**정답: C)** 단위 테스트는 빠르고, 저렴하고, 유지보수가 쉬워서
가장 많이 작성해야 합니다.

### Q3. 자동 테스트의 장점이 아닌 것은?
- A) 반복 실행 가능
- B) 코드 변경 시 회귀 버그 방지
- C) 모든 버그를 100% 잡을 수 있음
- D) 코드 동작 방식의 문서화 역할

**정답: C)** 자동 테스트도 모든 버그를 잡을 수는 없습니다.
하지만 테스트가 없는 것보다 훨씬 안전합니다.

## 7. 정리 및 다음 주제 예고

### 이번 강의 핵심 정리
- 테스트는 선택이 아닌 필수, 특히 예지보전처럼 안전이 중요한 시스템에서는 더욱 그렇다
- 버그는 늦게 발견될수록 수정 비용이 기하급수적으로 증가한다
- 자동 테스트는 반복 가능하고, 정확하며, 리팩토링의 안전망이 된다
- 테스트 피라미드: 단위 테스트를 기반으로 점진적으로 상위 테스트를 쌓는다

### 다음 주제 예고
**02. Python 내장 테스트: unittest & doctest** - Python에 기본 내장된
테스트 도구인 `unittest`와 `doctest`를 배웁니다. `unittest`의 TestCase 클래스,
setUp/tearDown 메서드, 다양한 assertion 메서드를 실습합니다.
