# 01. 왜 테스트가 필요한가

## 핵심 개념

### 수동 테스트 vs 자동 테스트
- 수동: 코드 수정 → 실행 → 눈으로 확인 → 느리고 빠뜨리기 쉬움
- 자동: 코드 수정 → pytest → 결과 즉시 확인 → 빠르고 반복 가능

### 테스트 피라미드
- **Unit Test**: 함수/클래스 단위. 빠르고 많이 작성. (예: `calc_rms()` 검증)
- **Integration Test**: 모듈 간 연결. (예: 센서 → 전처리 → DB 저장)
- **E2E Test**: 전체 시스템 흐름. 느리고 비쌈. 핵심 시나리오만. (예: 이상 감지 → 알람 발송)
- 원칙: Unit을 가장 많이, E2E는 핵심만

### 리팩토링 안전망
- 구현이 바뀌어도 테스트가 동작을 보장
- 예: 순수 Python → NumPy로 최적화해도 테스트는 그대로

### AI 시대: 테스트 = 행동 명세 + 경쟁력
- 전통적 관점: 테스트 = 버그 잡는 도구
- 새로운 관점: 테스트 = 소프트웨어가 어떻게 동작해야 하는지의 **실행 가능한 문서**
- AI가 코드를 쉽게 복제하는 시대 → 테스트(스펙)가 진짜 해자(moat)
- 사례: Cloudflare가 Vercel의 공개 테스트로 Next.js 호환 구현 / SQLite는 테스트 비공개 유지

## 실습 예제
- `src_sensor.py`: `calc_rms()`, `classify_vibration()` (ISO 10816 기준)
- `test_sensor.py`: 기본 케이스 + 경계값 테스트
- 경계값 테스트가 중요: 4.49 → 정상, 4.5 → 주의

## 연습문제
- `check_temperature()`: 60°C / 80°C 기준 상태 분류 + 경계값 테스트
